<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Blockchain Graph Analysis</title>
  <!-- Sigma core -->
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/sigma.core.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/conrad.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/utils/sigma.utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/utils/sigma.polyfills.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/sigma.settings.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.dispatcher.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.configurable.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.graph.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.camera.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.quad.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/classes/sigma.classes.edgequad.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/captors/sigma.captors.mouse.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/captors/sigma.captors.touch.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/sigma.renderers.canvas.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/sigma.renderers.webgl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/sigma.renderers.svg.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/sigma.renderers.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.labels.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.hovers.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.nodes.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edges.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edges.curve.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edges.arrow.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edges.curvedArrow.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edgehovers.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edgehovers.curve.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edgehovers.arrow.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.edgehovers.curvedArrow.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/renderers/canvas/sigma.canvas.extremities.def.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/middlewares/sigma.middlewares.rescale.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/middlewares/sigma.middlewares.copy.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/misc/sigma.misc.animation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/misc/sigma.misc.bindEvents.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/misc/sigma.misc.bindDOMEvents.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/src/misc/sigma.misc.drawHovers.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.edgeLabels/settings.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.def.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curve.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curvedArrow.js"></script>
  <!-- Sigma plugins -->
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.layout.forceAtlas2/supervisor.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.layout.forceAtlas2/worker.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.plugins.relativeSize/sigma.plugins.relativeSize.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.customShapes/shape-library.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/sigma@1.2.1/plugins/sigma.renderers.customShapes/sigma.renderers.customShapes.js"></script>
  <script src="https://rawgit.com/dawsonbotsford/satoshi-bitcoin/master/index.bundle.js"></script>
  <!--CSS-->
  <link rel="stylesheet" href="../static/style.css">
  <!--jquery-->
  <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
</head>

<body>
  <div style="width:18%; height:100%; float:right; text-align:left; padding: 1%;">
    <form id="form">
      <label for="txn">Tx Hash:</label><br>
      <input style="width: 100%;" type="text" id="txn" name="txn"><br>
      <div style="padding-top: 18px;">
        <input type="radio" id="graph" name="graphType" value="graph" checked>
        <label for="graph">Graph</label><br>
        <input type="radio" id="path" name="graphType" value="path">
        <label for="path">Path</label><br>
        <input type="radio" id="minimal_path" name="graphType" value="minimal_path">
        <label for="minimal_path">Minimal Path</label><br>
        <input type="submit" id="submit" name="submit"><br>
      </div>
    </form>
    <div style="padding-top: 18px; margin-top: 10px;margin-bottom: 10px;" id='inspected_node_details'></div>
    <div style="padding-top: 18px;">
      <div style="text-align: center;padding: 5px;"><u>Legend</u></div>
      <span>Inspected Transaction<div class="dot" style="background-color: #FF4500;"></div></span>
      <span>Input/Output Transactions<div class="dot" style="background-color: #EE651D;"></div></span>
      <span>UTXOs<div class="dot" style="background-color: #0000FF;"></div></span>
    </div>
    <div class="arrow" style="padding-top: 18px;">
      Tainted Path
      <div class="line"></div>
      <div class="point"></div>
    </div>
  </div>
  <div id='sigma-container' style="height: 70%;"></div>
  <div style="width: 80%;">
    <div style="padding: 10px;" id='hovered_node_details'>-</div>
    <div style="padding: 10px; overflow-x:auto;" id='addresses'></div>
  </div>
</body>

<script>
  sigma.utils.pkg('sigma.canvas.nodes');

  var blackList = [], whiteList = [], nodeIdList = [], edgeIdList = [];
  const THRESHOLD = 400;

  var s = new sigma(
    {
      renderer: {
        container: document.getElementById('sigma-container'),
        type: 'canvas',
      },
      settings: {
        edgeLabelSize: 'proportional',
        drawEdgeLabels: false,
        minArrowSize: 12,
        labelThreshold: 100,
        borderSize: 2,
        outerBorderSize: 3,
        defaultNodeOuterBorderColor: 'rgb(236, 81, 72)',
        enableEdgeHovering: true,
        edgeHoverHighlightNodes: 'circle',
        sideMargin: 1,
        edgeHoverColor: 'red',
        defaultEdgeHoverColor: '#FFFFFF',
        edgeHoverSizeRatio: 1,
        edgeHoverExtremities: true,
        drawEdgeLabels: true,
        drawBorder: true,
      }
    }
  );

  $("#submit").click(function (e) {
    e.preventDefault();

    var txn_hash = document.getElementById('txn').value;
    console.log(txn_hash);

    document.getElementById('inspected_node_details').innerHTML = "Transaction under Inspection: " + txn_hash;

    s.graph.clear();
    s.graph.read({
      nodes: [],
      edges: []
    });
    blackList = [];
    whiteList = [];
    nodeIdList = [];
    edgeIdList = [];

    const graphType = document.querySelector('input[name="graphType"]:checked').value;

    extendGraph(txn_hash, graphType);
  });

  function txns_to_new_graph_using_nodelist(txns) {
    var graph = {
      nodes: [],
      edges: []
    };
    for (const txn of txns) {
      if (nodeIdList.indexOf(txn["hash"]) == -1) {
        nodeIdList.push(txn["hash"]);
        graph.nodes.push({ id: txn["hash"] });
      }
      var txn_inputs = txn["inputs"];
      var txn_outputs = txn["outputs"];
      for (const tx_input of txn_inputs) {
        var nodeId = tx_input["prev_tx_hash"];
        if (tx_input["sender_address"] == "COINBASE") {
          nodeId = "COINBASE: " + txn["hash"];
        }
        if (nodeIdList.indexOf(nodeId) == -1) {
          nodeIdList.push(nodeId);
          graph.nodes.push({ id: nodeId });
        }
        var edgeId = nodeId + "-" + txn["hash"];
        if (edgeIdList.indexOf(edgeId) == -1) {
          edgeIdList.push(edgeId);
          graph.edges.push({ id: edgeId, source: nodeId, target: txn["hash"], amount: tx_input["amount"], address: tx_input["sender_address"] });
        }
      }

      for (var j = 0; j < txn_outputs.length; j++) {
        const tx_output = txn_outputs[j];
        var nodeId = tx_output["next_tx_hash"];
        if (tx_output["next_tx_hash"] == "") { // UTXO
          nodeId = "UTXO " + j + ": " + txn["hash"];
        }
        if (nodeIdList.indexOf(nodeId) == -1) {
          nodeIdList.push(nodeId);
          graph.nodes.push({ id: nodeId });
        }
        var edgeId = txn["hash"] + "-" + nodeId;
        if (edgeIdList.indexOf(edgeId) == -1) {
          edgeIdList.push(edgeId);
          graph.edges.push({ id: edgeId, source: txn["hash"], target: nodeId, amount: tx_output["amount"], address: tx_output["receiver_address"] });
        }
      }
    }
    return graph;
  }

  function nodeColor(nodeName) {
    if (nodeName[0] == "U") { // UTXO
      return "#0000FF";
    }
    else if (nodeName[0] == "C") { // COINBASE
      return "#FFFF00";
    }
    else return "#FF9966";
  }

  function getData(txn, graphType) {
    // var url = "http://nextcloud.somecha.in";
    var url = "http://127.0.0.1:5000";
    if(graphType == "path") {
      url += "/tx_path/" + txn;
    } else if(graphType == "minimal_path") {
      url += "/tx_minimal_path/" + txn;
    } else { // graph
      url += "/tx/" + txn;
    }
    var dump;
    $.ajax({
      url: url,
      async: false,
      dataType: 'json',
      success: function (d) {
        dump = d;
      }
    });
    return dump;
  }

  function extendGraph(txn_hash, graphType) {
    if(typeof graphType == 'undefined') {
      graphType = "graph";
    }
    var dump = getData(txn_hash, graphType);
    if (dump == undefined) {
      return;
    }

    blackList = blackList.concat(dump["blacklist"]);
    whiteList = whiteList.concat(dump["whitelist"]);

    var l = nodeIdList.length;

    var newGraphData = txns_to_new_graph_using_nodelist(dump["txns"]);

    if (nodeIdList.length == l) {
      alert('Tx Already Explored!')
      // no new nodes
      return;
    }
    if (nodeIdList.length > THRESHOLD) {
      alert('Node Limit Reached!')
      return;
    }

    for (var i = 0; i < newGraphData.nodes.length; i++) {
      s.graph.addNode(getNode(newGraphData.nodes[i], i == 0 && l == 0)); // l == 0 checks that it is the first time we are adding nodes
    }

    for (var i = 0; i < newGraphData.edges.length; i++) {
      s.graph.addEdge(getEdge(newGraphData.edges[i]));
    }

    var graph_edges = s.graph.edges();

    const normal_edge_color = "babyblue";
    const white_edge_color = "yellow";
    const black_edge_color = "black";
    const grey1_edge_color = "grey";
    const grey2_edge_color = "silver";
    const whites = {};
    const blacks = {};
    const grey1s = {};
    const grey2s = {};
    for(const add of blackList) {
      blacks[add] = true;
    }
    for(const add of whiteList) {
      whites[add] = true;
    }
    for (var edge of graph_edges) {
      if (edge.address == "COINBASE" || whites[edge.address]) {
        edge.color = white_edge_color;
      }
    }
    for (var edge of graph_edges) {
      if (blacks[edge.address]) {
        edge.color = black_edge_color;
        graph_edges.forEach(ed => {
          if (ed.target == edge.source) { // input edge
            if (!blacks[ed.address] && !whites[ed.address]) {
              ed.color = grey1_edge_color;
              grey1s[ed.address] = true;
              graph_edges.forEach(e => {
                if (e.target == ed.source) { // input edge
                  if (!blacks[e.address] && !whites[e.address] && !grey1s[e.address]) {
                    e.color = grey2_edge_color;
                    grey2s[e.address] = true;
                  }
                }
              });
            }
          }
        });
        graph_edges.forEach(ed => {
          if (ed.source == edge.target) { // output edge
            if (!blacks[ed.address] && !whites[ed.address]) {
              ed.color = grey1_edge_color;
              grey1s[ed.address] = true;
              graph_edges.forEach(e => {
                if (e.source == ed.target) { // output edge
                  if (!blacks[e.address] && !whites[e.address] && !grey1s[e.address]) {
                    e.color = grey2_edge_color;
                    grey2s[e.address] = true;
                  }
                }
              });
            }
          }
        });
      }
    }
    var addresses =
    "<tr><th>White</th><td>" + Object.keys(whites) + "</td></tr>" +
    "<tr><th>Black</th><td>" + Object.keys(blacks) + "</td></tr>" +
    "<tr><th>Grey1</th><td>" + Object.keys(grey1s) + "</td></tr>" +
    "<tr><th>Grey2</th><td>" + Object.keys(grey2s) + "</td></tr>";
    document.getElementById('addresses').innerHTML = "<table><tbody>"+addresses+"</tbody></table>";

    s.refresh();
    s.startForceAtlas2();
    window.setTimeout(function () { s.killForceAtlas2() }, 1000);
  }

  function getNode(nodeData, is_main) {
    var radius = 2;
    var x_coord = Math.random() * 2 * radius - radius;
    var ylim = Math.sqrt(radius * radius - x_coord * x_coord);
    var y_coord = Math.random() * 2 * ylim - ylim;
    var node = {
      id: nodeData["id"],
      label: nodeData["id"],
      x: x_coord,
      y: y_coord,
      size: 40,
      color: nodeColor(nodeData["id"])
    };
    if (is_main) {
      node.size = 50;
      node.color = '#ff4500';
      node.borderColor = '#000000';
    }
    return node;
  }

  function getEdge(edgeData) {
    return {
      id: edgeData["id"],
      // label: sb.toBitcoin(edgeData["amount"]) + " BTC",
      label: edgeData["amount"] + " (" + edgeData["address"].substring(0, 5) + "...)",
      source: edgeData["source"],
      target: edgeData["target"],
      color: "#89CFF0",
      type: "arrow",
      address: edgeData["address"],
      amount: edgeData["amount"],
    }
  }

  s.bind('clickNode doubleClickNode', function (e) {
    console.log(e.data.node.id, e.type, e.data.node.label, e.data.captor);
    var label = e.data.node.label;
    if (!label.startsWith("UTXO") && !label.startsWith("COINBASE")) {
      extendGraph(e.data.node.id);
    }
  });

  s.bind('overNode', function (e) {
    var id = e.data.node.id;
    var input = 0;
    var output = 0;
    s.graph.edges().forEach(edge => {
      if(edge.source == id) {
        output += edge.amount;
      } else if(edge.target == id) {
        input += edge.amount;
      }
    });
    if (id[0] === "U") {
      document.getElementById('hovered_node_details').innerHTML = 'UTXO - ' + sb.toBitcoin(input).toFixed(8) + ' BTC';
    }
    else if (id[0] === "C") {
      document.getElementById('hovered_node_details').innerHTML = 'COINBASE - ' + sb.toBitcoin(output).toFixed(8) + ' BTC';
    }
    else {
      document.getElementById('hovered_node_details').innerHTML = `TXN ${id}; Input: ${sb.toBitcoin(input).toFixed(8)} BTC; Output: ${sb.toBitcoin(output).toFixed(8)} BTC`;
    }
  });

  s.bind('overEdge', function (e) { // Doesn't work
    // TODO
    // console.log('overEdge');
    // s.settings('drawEdgeLabels', true);
  })

</script>

</html>